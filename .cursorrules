# 프로젝트 개발 규칙 (.cursorrules)

이 파일은 Cursor AI 어시스턴트가 프로젝트 개발 시 반드시 준수해야 하는 규칙들을 정의합니다.
DEVELOPMENT_GUIDELINES.md 파일의 핵심 내용을 기반으로 하며, 모든 코드 작성 및 리뷰 시 이 규칙을 우선적으로 적용합니다.

## 관련 문서 참조

더 자세한 내용은 다음 문서들을 참고하세요:
- **[DEVELOPMENT_GUIDELINES.md](../DEVELOPMENT_GUIDELINES.md)**: 전체 개발 가이드라인 및 프로세스
- **[docs/README.md](docs/README.md)**: 문서 구조 및 개요
- **[docs/requirements.md](docs/requirements.md)**: 프로젝트 요구사항
- **[docs/development/setup.md](docs/development/setup.md)**: 개발 환경 설정
- **[docs/architecture/overview.md](docs/architecture/overview.md)**: 아키텍처 개요
- **[docs/task-management/README.md](docs/task-management/README.md)**: 태스크 관리 가이드

## 핵심 개발 원칙

### 1. 오버엔지니어링 방지
- KISS 원칙 준수: 불필요하게 복잡한 설계를 피합니다
- YAGNI 원칙 준수: 실제로 필요한 기능만 구현합니다
- 현재 요구사항에만 집중합니다

### 2. TDD (Test-Driven Development) 필수
- Red-Green-Refactor 사이클 준수
- 기능 구현 전에 반드시 테스트를 먼저 작성합니다
- 모든 테스트가 통과하지 않으면 다음 단계로 진행하지 않습니다
- 📖 자세한 내용: [DEVELOPMENT_GUIDELINES.md](../DEVELOPMENT_GUIDELINES.md#04-개발-프로세스-문서--테스트--개발--커밋--pr--태스크-업데이트)

### 3. 커밋 관리
- 하나의 커밋은 최대 100라인으로 유지
- 하나의 커밋은 하나의 논리적 변경사항만 포함
- 빈번한 커밋을 권장합니다
- **모든 작업 즉시 커밋**: 코드 변경, 문서 업데이트, 설정 변경 등 모든 작업을 즉시 커밋합니다
- **작업 단위별 커밋**: 논의, 계획, 구현, 테스트 등 각 단계별로 커밋합니다
- **모든 커밋 즉시 푸시**: 모든 커밋 후 즉시 원격 저장소에 푸시합니다
- 📖 자세한 내용: [DEVELOPMENT_GUIDELINES.md](../DEVELOPMENT_GUIDELINES.md#03-git-관리-커밋--푸시)

### 3-1. Git 브랜치 및 푸시 자동화 (필수)
- **브랜치 자동 생성**: 모든 작업 시작 전에 반드시 새로운 브랜치를 생성합니다
  - **모든 브랜치는 develop 브랜치에서 분기**: 작업 시작 전 develop 브랜치로 체크아웃하고 최신 상태로 업데이트한 후 새 브랜치 생성 (규칙 10-1 참조)
  - 기능 개발: `feature/작업-설명` 형식 (예: `feature/user-authentication`)
  - 버그 수정: `bugfix/작업-설명` 형식 (예: `bugfix/login-error`)
  - 문서 작업: `docs/작업-설명` 형식 (예: `docs/api-documentation`)
  - 리팩토링: `refactor/작업-설명` 형식 (예: `refactor/user-service`)
  - 테스트: `test/작업-설명` 형식 (예: `test/coverage-improvement`)
- **브랜치 생성 후 즉시 체크아웃**: 새 브랜치를 생성하면 반드시 해당 브랜치로 전환합니다
- **커밋 자동화**: 코드 변경사항이 있을 때마다 자동으로 커밋합니다
  - 커밋 메시지는 규칙 11의 형식을 따릅니다
  - 테스트 통과 후에만 커밋합니다
- **푸시 자동화**: 모든 커밋 후 즉시 원격 저장소에 푸시합니다
  - `git push origin <브랜치명>` 형식으로 푸시합니다
  - 첫 푸시 시 `-u` 옵션을 사용하여 upstream을 설정합니다
- **PR 자동 생성**: 작업 완료 후 자동으로 Pull Request를 생성합니다
  - GitHub CLI (`gh`)를 사용하여 PR 생성 (`gh pr create --title "type(scope): subject" --body "작업 설명"`)
  - PR은 기본적으로 `develop` 브랜치로 향하도록 설정합니다
  - PR 제목은 커밋 메시지 형식을 따릅니다
  - PR 본문에는 작업 내용, 변경사항, 테스트 결과를 포함합니다
- **작업 완료 전 브랜치 유지**: 작업이 완전히 끝날 때까지 브랜치를 유지합니다

## 코드 품질 및 스타일

### 4. 코드 스타일
- Python: PEP 8 준수
- 함수/변수: snake_case
- 클래스: PascalCase
- 상수: UPPER_SNAKE_CASE
- 줄 길이: 88자 이내
- 들여쓰기: 스페이스 4개

### 5. 코드 구조
- 각 모듈은 단일 책임을 가짐
- 함수는 20줄 이내로 유지
- 불필요한 주석은 피함

## 서버 아키텍처 (DDD 기반)

### 6. DDD 레이어 구조
- **Domain Layer**: Entity, Value Object, Domain Service, Aggregate
- **Application Layer**: Application Service, Command/Query 객체
- **Infrastructure Layer**: Repository 구현, 외부 서비스 어댑터
- **Presentation Layer**: Controller, DTO, API 문서화
- 📖 자세한 내용: [docs/architecture/overview.md](docs/architecture/overview.md), [docs/architecture/repositories.md](docs/architecture/repositories.md)

### 7. DDD 구현 원칙
- 의존성 역전 원칙 준수
- 단일 책임 원칙 적용
- 개방 폐쇄 원칙 준수
- 인터페이스 분리 원칙 적용

## 테스트 전략

### 7-1. 테스트 디렉토리 구조 (필수)
- **테스트 디렉토리 분리**: 백엔드와 프론트엔드 테스트를 명확히 분리합니다
- **백엔드 테스트 위치**: `tests/backend/` 디렉토리에 모든 백엔드 테스트를 작성합니다
  - `tests/backend/unit/`: 단위 테스트 (도메인, 인프라, 프레젠테이션 레이어)
  - `tests/backend/scenario/`: 시나리오 테스트 (API 엔드포인트 간 상호작용)
  - `tests/backend/acceptance/`: Acceptance 테스트 (전체 시스템 검증)
- **프론트엔드 테스트 위치**: `tests/frontend/` 디렉토리에 모든 프론트엔드 테스트를 작성합니다
  - `tests/frontend/unit/`: 유닛 테스트 (유틸리티, 비즈니스 로직)
  - `tests/frontend/component/`: 컴포넌트 테스트 (React 컴포넌트)
  - `tests/frontend/e2e/`: E2E 테스트 (Playwright)
- **테스트 파일 네이밍**: 
  - 백엔드: `test_*.py` 형식 (예: `test_user.py`, `test_auth.py`)
  - 프론트엔드: `*.test.ts`, `*.test.tsx` 형식 (예: `User.test.tsx`, `utils.test.ts`)
- **새로운 테스트 작성 시**: 반드시 해당 디렉토리 구조에 맞춰 작성합니다

### 8. 테스트 커버리지 필수 요구사항 (강제)
- 백엔드: 최소 80% 코드 커버리지 필수 (미달 시 테스트 실패)
- 프론트엔드: 최소 80% 코드 커버리지 필수 + 주요 사용자 플로우 100% 커버리지 (미달 시 테스트 실패)
- 새로운 기능 추가 시 반드시 해당 영역의 테스트 코드를 작성합니다
- 커버리지 미달 시 모든 작업 중단 및 테스트 작성 우선 진행
- 📖 자세한 내용: [DEVELOPMENT_GUIDELINES.md](../DEVELOPMENT_GUIDELINES.md#31-백엔드-테스트-종류)

### 8-1. 시나리오 테스트 필수 요구사항 (강제)
- **시나리오 테스트 필수 작성**: 모든 주요 사용자 플로우에 대한 시나리오 테스트를 반드시 작성합니다
- **시나리오 테스트 파일 위치**: `tests/backend/scenario/` 디렉토리에 시나리오 테스트를 작성합니다
  - 기능별로 파일을 분리하여 작성 (예: `test_user_scenarios.py`, `test_test_taking_scenarios.py`)
- **시나리오 테스트 범위**: 
  - 여러 API 엔드포인트 간 상호작용 검증
  - 실제 사용자 플로우 전체 검증 (예: 사용자 생성 → 시험 시작 → 문제 조회 → 답안 제출 → 결과 조회)
  - 데이터 흐름 및 상태 전이 검증
- **새로운 기능 추가 시**: 해당 기능을 포함하는 시나리오 테스트를 반드시 추가합니다
- **시나리오 테스트 작성 원칙**:
  - 하나의 시나리오 테스트는 하나의 완전한 사용자 플로우를 검증합니다
  - 테스트 이름은 "test_scenario_<사용자_행동>_<예상_결과>" 형식을 따릅니다 (예: `test_scenario_user_takes_test_and_views_result`)
  - 실제 사용자가 수행하는 순서대로 API를 호출합니다
  - 각 단계의 응답을 검증하고, 다음 단계에 필요한 데이터를 추출하여 사용합니다
- **시나리오 테스트 실행**: 모든 단위 테스트와 함께 시나리오 테스트도 실행되며, 실패 시 작업 진행 금지
- 📖 자세한 내용: [DEVELOPMENT_GUIDELINES.md](../DEVELOPMENT_GUIDELINES.md#31-백엔드-테스트-종류)

### 9. 테스트 안티패턴 금지
- 데이터베이스 직접 테스트 금지 (목 사용)
- 외부 API 호출 금지 (목 사용)
- 시간 의존적 테스트 금지
- 비결정적 테스트 금지
- 테스트 간 상태 공유 금지
- DOM 직접 조작 금지 (프론트엔드)
- 구현 세부사항 테스트 금지

## 버전 관리 (Git)

### 10. 브랜치 전략
- main: 프로덕션 배포용
- develop: 통합 브랜치
- feature/*: 새로운 기능
- bugfix/*: 버그 수정
- hotfix/*: 긴급 수정
- **모든 작업은 새 브랜치에서 진행**: develop이나 main 브랜치에서 직접 작업하지 않습니다
- **모든 브랜치는 develop에서 분기**: 모든 작업 브랜치(feature, bugfix, docs, refactor, test)는 반드시 develop 브랜치에서 분기합니다
- **브랜치 필수 생성**: 모든 작업은 새로운 브랜치를 생성하여 진행합니다
- **작업 단위별 브랜치**: 하나의 논리적 작업 단위마다 별도 브랜치를 생성합니다
- 📖 자세한 내용: [DEVELOPMENT_GUIDELINES.md](../DEVELOPMENT_GUIDELINES.md#21-브랜치-전략), [docs/development/setup.md](docs/development/setup.md#git-저장소-설정)

### 10-1. 브랜치 최신화 필수 규칙 (강제)
- **모든 작업 시작 전 필수**: 모든 작업을 시작하기 전에 반드시 브랜치를 최신화합니다
- **develop 브랜치 최신화**: 작업 시작 전 develop 브랜치로 체크아웃한 후 `git pull origin develop` (또는 `git fetch origin && git merge origin/develop`) 명령어로 최신 상태로 업데이트합니다
- **최신화 확인**: `git status` 또는 `git log` 명령어로 최신 상태인지 확인합니다
- **최신화 후 브랜치 생성**: develop 브랜치를 최신화한 후에만 새 작업 브랜치를 생성합니다
- **기존 브랜치 작업 시**: 기존 브랜치에서 작업을 계속하는 경우에도 작업 시작 전 `git pull origin develop` 명령어로 develop 브랜치를 최신화하고, 필요시 `git merge origin/develop` 또는 `git rebase origin/develop` 명령어로 현재 브랜치를 최신화합니다
- **최신화 실패 시**: 최신화 중 충돌이 발생하면 먼저 충돌을 해결한 후 작업을 진행합니다
- **최신화 없이는 작업 시작 금지**: 브랜치를 최신화하지 않으면 절대 작업을 시작하지 않습니다

### 11. 커밋 메시지 형식
```
type(scope): subject

body

footer
```
- type: feat, fix, docs, style, refactor, test, chore
- scope: 변경 영역 (api, ui, db 등)
- subject: 50자 이내 요약

## 보안 및 성능

### 12. 보안 원칙
- 민감한 정보는 환경 변수로 관리
- 입력값 철저한 검증
- SQL 인젝션, XSS 등 취약점 방지

### 13. 성능 기준
- API 응답: 500ms 이내
- DB 쿼리: N+1 문제 방지
- 메모리 사용량: 합리적 범위 유지

## AI 어시스턴트 행동 지침

### 14. 코드 작성 시 준수사항
- 모든 코드는 위 규칙을 우선적으로 따름
- TDD 방식으로 개발 진행
- 오버엔지니어링을 피하고 간단한 해결책 선택
- 테스트를 먼저 작성하고 구현
- 커밋은 작고 의미있게 유지
- **작업 시작 전 반드시 새 브랜치 생성 및 체크아웃**
- **모든 변경사항 즉시 커밋 및 푸시**
- **작업 완료 시 반드시 PR 생성 (필수)**

### 14-1. Git 작업 자동화 프로세스 (필수)
1. **작업 시작 시**:
   - 현재 브랜치 확인 (`git branch` 또는 `git status`)
   - **develop 브랜치로 체크아웃**: `git checkout develop`
   - **브랜치 최신화 (필수)**: `git pull origin develop` (또는 `git fetch origin && git merge origin/develop`) - 규칙 10-1 참조
   - 최신화 확인 (`git status` 또는 `git log`)
   - 작업 유형에 맞는 새 브랜치 생성 (`git checkout -b feature/작업명` 등)
   - 새 브랜치로 체크아웃 확인

2. **코드 변경 후**:
   - 변경사항 확인 (`git status`)
   - 테스트 실행 및 통과 확인
   - 변경사항 스테이징 (`git add .` 또는 특정 파일)
   - 규칙 11에 따른 커밋 메시지로 커밋 (`git commit -m "type(scope): subject"`)
   - 즉시 원격 저장소에 푸시 (`git push -u origin <브랜치명>` 또는 `git push`)

3. **작업 완료 시 (필수 체크리스트 - 모두 완료해야 작업 완료로 간주)**:
   - [ ] **`run_tests.sh` 실행 및 성공 확인 (필수 - 이 단계가 없으면 작업 미완료)**
     - `./run_tests.sh` 스크립트를 실행합니다
     - 스크립트의 exit code가 0인지 확인합니다 (0이 아니면 작업 완료 불가)
     - 모든 단위 테스트가 통과했는지 확인합니다
     - 모든 시나리오 테스트가 통과했는지 확인합니다
     - 커버리지 요구사항 충족 확인 (백엔드 80%, 프론트엔드 80%)
     - 테스트 실패 시 원인 파악 및 수정 후 재실행
     - 규칙 20의 모든 요구사항 준수 확인
   - [ ] 모든 변경사항 커밋 및 푸시 확인
   - [ ] 브랜치 상태 확인
   - [ ] **태스크 관리 문서 업데이트 (필수 - 이 단계가 없으면 작업 미완료)**
     - `docs/task-management/current-sprint.md` 업데이트 (완료된 태스크 추가, 진행률 재계산)
     - `docs/task-management/backlog.md` 업데이트 (태스크 상태 변경, 진행률 재계산)
     - 업데이트 내용 커밋 및 푸시
     - 규칙 23의 모든 요구사항 준수 확인
   - [ ] **설계 문서 업데이트 (필수 - 이 단계가 없으면 작업 미완료)**
     - 코드 변경 즉시 `docs/` 폴더의 관련 문서 업데이트
     - Backend 변경 시: Entity/Domain Service → `docs/architecture/domain/`, Repository → `docs/architecture/repositories.md`, API → `docs/api/endpoints/`, DTO/스키마 → `docs/api/schemas/`
     - Frontend 변경 시: 컴포넌트 구조 → 프론트엔드 아키텍처 문서, API 호출 → `docs/api/` 문서
     - 아키텍처 변경 시 → `docs/architecture/overview.md` 업데이트
     - `docs/CHANGELOG.md`에 모든 변경사항 기록
     - 규칙 17의 모든 요구사항 준수 확인
   - [ ] **Pull Request 자동 생성 (필수 - 이 단계가 없으면 작업 미완료)**
     - GitHub CLI 사용: `gh pr create --title "type(scope): subject" --body "작업 설명 및 변경사항" --base develop`
     - 또는 스크립트 사용: `./scripts/create_pr.sh`
     - PR 제목은 마지막 커밋 메시지 형식을 따릅니다
     - PR 본문에는 작업 내용, 주요 변경사항, 테스트 결과를 포함합니다
     - PR 생성 후 PR URL을 사용자에게 반드시 알립니다
   - [ ] **PR 생성 실패 시**: 사용자에게 명시적으로 알리고 수동 생성 안내

**중요**: `run_tests.sh` 실행 및 성공 확인, 태스크 관리 문서 업데이트, 설계 문서 업데이트, PR 생성 없이는 작업을 완료한 것으로 간주하지 않습니다. 작업 완료 선언 전 반드시 이 모든 항목을 확인합니다.

### 15. 리뷰 및 피드백 시 준수사항
- DEVELOPMENT_GUIDELINES.md 위반 사항 즉시 지적
- 테스트 커버리지 필수 확인: 백엔드 80%, 프론트엔드 80% 미달 시 즉시 중단
- 커버리지 미달 시 테스트 작성 후 재실행 필수
- 보안 및 성능 이슈 검토
- 코드 가독성 및 유지보수성 평가

### 16. 문제 해결 시 접근방식
- 가장 간단하고 직접적인 해결책 우선 고려
- 불필요한 추상화나 복잡성 피함
- 실제 요구사항에 기반한 구현
- 테스트로 검증된 변경사항만 승인

### 17. 문서화 요구사항
- 코드 변경 즉시 docs/ 폴더의 관련 문서 업데이트
- 새로운 기능 추가 시 해당 기능 문서 생성
- API 변경 시 docs/api/ 폴더 문서 업데이트
- 아키텍처 변경 시 docs/architecture/ 문서 업데이트
- 문서 리팩토링 필요시 즉시 수행
- CHANGELOG.md에 모든 변경사항 기록
- 📖 자세한 내용: [docs/README.md](docs/README.md), [docs/CHANGELOG.md](docs/CHANGELOG.md)

### 18. 프론트엔드 특화 규칙
- Atomic Design 패턴으로 컴포넌트 구조화
- 단방향 데이터 흐름과 컴포넌트 합성 우선 사용
- WCAG 2.1 AA 준수로 접근성 보장
- React.memo, useMemo, useCallback으로 성능 최적화
- 모바일 우선 반응형 디자인 적용
- 브라우저 호환성과 점진적 향상 고려

### 18-1. 프론트엔드 테스트 전략 (필수)
- **테스트 도구 스택**: 
  - 유닛/컴포넌트: Vitest (또는 Jest) + Testing Library
  - E2E: Playwright
  - API 목킹: MSW (Mock Service Worker)
- **테스트 범위 결정 기준**:
  1. **로직은 유닛, UI 상호작용은 컴포넌트, 전체 흐름은 E2E**
     - 유닛 테스트: 순수 함수, 유틸리티, 비즈니스 로직
     - 컴포넌트 테스트: React 컴포넌트의 렌더링 및 상호작용
     - E2E 테스트: 실제 브라우저에서의 전체 사용자 플로우
  2. **테스트는 "사용자가 보는 것" 기준으로 작성**
     - 화면에 보이는 텍스트, role, label로 검증
     - 구현 세부사항 테스트 금지 (내부 상태, props 구조 직접 테스트 금지)
     - 접근성 고려: ARIA role, label, name 속성 활용
  3. **네트워크는 MSW로 성공/실패/지연 케이스를 쉽게 만들기**
     - MSW를 사용하여 실제 네트워크 요청을 가로채서 목킹
     - 성공, 실패, 지연, 타임아웃 등 다양한 시나리오 테스트
     - 실제 API 스펙 반영: OpenAPI 스펙 기반으로 핸들러 작성
  4. **스냅샷 테스트는 남발 금지 (진짜 가치 있는 UI만)**
     - 중요한 UI 컴포넌트, 복잡한 레이아웃, 디자인 시스템 컴포넌트에만 사용
     - 단순한 컴포넌트, 자주 변경되는 컴포넌트, 동적 데이터 포함 컴포넌트에는 사용 금지
- **테스트 커버리지**: 최소 80% 코드 커버리지 + 주요 사용자 플로우 100% 커버리지 필수
- 📖 자세한 내용: [docs/development/frontend-testing.md](docs/development/frontend-testing.md)

### 19. 태스크 및 스프린트 관리 (강제)
- 1주 단위 스프린트 운영으로 작업 관리
- 우선순위 기반(P0-P3) 태스크 처리
- 모든 태스크는 수용 기준과 템플릿 준수
- 스프린트 문서와 백로그 실시간 업데이트
- **작업 완료 후 반드시 태스크 관리 문서 업데이트 (필수 - 규칙 23 참조)**
- 📖 자세한 내용: [docs/task-management/README.md](docs/task-management/README.md), [docs/task-management/backlog.md](docs/task-management/backlog.md), [docs/task-management/current-sprint.md](docs/task-management/current-sprint.md)

### 20. 테스트 실행 및 커버리지 검증 (필수 - 매우 중요)
**이 규칙은 작업 완료의 필수 조건입니다. 위반 시 작업을 완료한 것으로 간주하지 않습니다.**

- **작업 완료 선언 전 필수 실행**: 모든 작업 완료 선언 전에 반드시 `./run_tests.sh` 스크립트를 실행합니다
- **테스트 실패 시 작업 완료 금지**: `run_tests.sh`가 실패하면 (exit code != 0) 절대 작업 완료를 선언하지 않습니다
- **테스트 성공 확인 필수**: `run_tests.sh`가 성공적으로 완료되어야만 (exit code == 0) 작업 완료를 선언할 수 있습니다
- 모든 테스트 실행 시 커버리지 체크 필수 포함
- 백엔드 커버리지 80% 미달 시 테스트 실패로 처리
- 프론트엔드 커버리지 80% 미달 시 테스트 실패로 처리
- 커버리지 미달 시 다음 작업 진행 금지
- `run_tests.sh` 스크립트에 커버리지 임계값 검증 포함

#### 20-1. 작업 완료 전 테스트 실행 프로세스 (필수)
1. **작업 완료 선언 직전 필수 실행**:
   - `./run_tests.sh` 스크립트를 실행합니다
   - 스크립트 실행 결과의 exit code를 확인합니다
   - exit code가 0이 아니면 작업 완료를 선언하지 않습니다

2. **테스트 실패 시 조치**:
   - 테스트 실패 원인을 파악합니다
   - 테스트를 수정하거나 누락된 테스트를 작성합니다
   - `run_tests.sh`가 성공할 때까지 반복합니다
   - 테스트가 성공하기 전에는 절대 작업 완료를 선언하지 않습니다

3. **테스트 성공 확인**:
   - `run_tests.sh`의 exit code가 0인지 확인합니다
   - 모든 단위 테스트가 통과했는지 확인합니다
   - 모든 시나리오 테스트가 통과했는지 확인합니다
   - 커버리지 요구사항(백엔드 80%, 프론트엔드 80%)을 충족했는지 확인합니다
   - 위 모든 조건이 충족되어야만 작업 완료를 선언할 수 있습니다

**중요**: `run_tests.sh` 실행 및 성공 확인 없이는 절대 작업 완료를 선언하지 않습니다.

#### 20-2. TypeScript 타입 체크 필수 요구사항 (강제)
- **프론트엔드 작업 시 타입 체크 필수**: 모든 프론트엔드 코드 변경 시 TypeScript 타입 체크를 반드시 수행합니다
- **타입 체크 실행 시점**: `run_tests.sh` 스크립트에서 프론트엔드 테스트 실행 전에 자동으로 타입 체크를 수행합니다
- **타입 에러 시 작업 완료 금지**: 타입 체크가 실패하면 (exit code != 0) 절대 작업 완료를 선언하지 않습니다
- **타입 체크 통과 필수**: 타입 체크가 성공적으로 완료되어야만 (exit code == 0) 다음 단계로 진행할 수 있습니다
- **타입 체크 스크립트**: `npm run typecheck` 명령어로 수동 실행 가능 (개발 중 빠른 피드백)
- **test:ci 스크립트**: `npm run test:ci` 실행 시 자동으로 타입 체크를 포함하여 실행됩니다

**중요**: TypeScript 타입 체크 실패 시 모든 작업을 중단하고 타입 에러를 수정한 후 다시 진행합니다.

### 21. 작업 완료 기준 (필수 - 모두 충족해야 작업 완료)
작업 완료 선언 전 반드시 다음 항목을 모두 확인:
1. ✅ 기능 구현 완료
2. ✅ **`run_tests.sh` 실행 및 성공 확인 (필수)** ← 이 단계가 없으면 작업 미완료
   - `./run_tests.sh` 실행 및 exit code == 0 확인
   - 프론트엔드 TypeScript 타입 체크 통과 확인 (규칙 20-2 참조)
   - 모든 단위 테스트 통과 확인
   - 모든 시나리오 테스트 통과 확인
   - 커버리지 요구사항 충족 확인 (백엔드 80%, 프론트엔드 80%)
   - 규칙 20의 모든 요구사항 준수 확인
3. ✅ 모든 변경사항 커밋 및 푸시
4. ✅ **태스크 관리 문서 업데이트 완료** ← 이 단계가 없으면 작업 미완료 (규칙 23 참조)
5. ✅ **설계 문서 업데이트 완료** ← 이 단계가 없으면 작업 미완료 (규칙 17 참조)
   - 코드 변경 즉시 `docs/` 폴더의 관련 문서 업데이트
   - Backend 변경 시: Entity/Domain Service → `docs/architecture/domain/`, Repository → `docs/architecture/repositories.md`, API → `docs/api/endpoints/`, DTO/스키마 → `docs/api/schemas/`
   - Frontend 변경 시: 컴포넌트 구조 → 프론트엔드 아키텍처 문서, API 호출 → `docs/api/` 문서
   - 아키텍처 변경 시 → `docs/architecture/overview.md` 업데이트
   - `docs/CHANGELOG.md`에 모든 변경사항 기록
6. ✅ **Pull Request 생성 완료** ← 이 단계가 없으면 작업 미완료
7. ✅ PR URL 사용자에게 전달

**중요**: `run_tests.sh` 실행 및 성공 확인, PR 생성, 태스크 관리 문서 업데이트, 설계 문서 업데이트 없이는 작업을 완료한 것으로 간주하지 않습니다.

### 22. PR 생성 필수 규칙 (강제)
- **모든 feature/bugfix/docs/refactor/test 브랜치는 작업 완료 시 반드시 PR 생성**
- PR 생성 없이는 작업을 완료한 것으로 간주하지 않음
- PR 생성 실패 시:
  1. 사용자에게 즉시 알림
  2. PR 생성 명령어 제공
  3. 수동 생성 안내
- PR 생성 후 PR URL을 반드시 사용자에게 전달
- PR 생성 확인: `gh pr list --head <브랜치명>` 명령어로 확인 가능

### 23. 태스크 관리 문서 업데이트 필수 규칙 (강제 - 매우 중요)
**이 규칙은 작업 완료 시 반드시 준수해야 하는 필수 규칙입니다. 위반 시 작업을 완료한 것으로 간주하지 않습니다.**

#### 23-1. 업데이트 시점 (필수)
- **모든 작업 완료 직후 즉시 업데이트**: PR 생성 전에 반드시 태스크 관리 문서를 업데이트합니다
- **작업 완료 선언 전 필수 확인**: 작업 완료를 선언하기 전에 반드시 태스크 관리 문서 업데이트 여부를 확인합니다
- **업데이트 없이는 작업 미완료**: 태스크 관리 문서를 업데이트하지 않으면 작업을 완료한 것으로 간주하지 않습니다

#### 23-2. 업데이트 대상 문서 (필수)
다음 문서들을 반드시 업데이트합니다:
1. **`docs/task-management/current-sprint.md`** (필수)
   - 완료된 태스크를 "완료된_태스크" 섹션에 추가
   - 태스크 ID, 제목, 완료일, 포인트 정보 포함
   - 진행률(완료_포인트, 진행률) 자동 재계산 및 업데이트
   - "진행중_태스크_수" 업데이트 (완료된 태스크 제거)
   - "최근_활동_로그"에 완료 내역 추가
   - 백로그에서 해당 태스크 제거 또는 상태 변경

2. **`docs/task-management/backlog.md`** (필수)
   - 완료된 태스크의 상태를 "완료"로 변경
   - 완료_포인트 및 진행률 자동 재계산 및 업데이트
   - 에픽 상태 업데이트 (해당 에픽의 완료율 재계산)
   - 우선순위_분포 업데이트
   - 태스크가 에픽에 속한 경우 에픽의 완료율도 업데이트

#### 23-3. 업데이트 내용 (필수)
각 문서에 다음 정보를 반드시 포함합니다:
- **태스크 식별자**: 태스크 ID 또는 고유 식별자
- **태스크 제목**: 작업한 태스크의 명확한 제목
- **완료일**: 작업 완료 날짜 (YYYY-MM-DD 형식)
- **포인트**: 태스크의 스토리 포인트
- **상태 변경**: "진행중" → "완료" 또는 "백로그" → "완료"
- **진행률 재계산**: 완료_포인트, 진행률 자동 재계산
- **메타데이터 업데이트**: 총_태스크_수, 완료_포인트 등 모든 관련 메타데이터 업데이트

#### 23-4. 업데이트 프로세스 (필수)
1. **작업 완료 확인 후 즉시 실행**:
   - 테스트 통과 및 커버리지 확인 후
   - 커밋 및 푸시 전 또는 후 (반드시 PR 생성 전)
   - PR 생성 직전에 반드시 완료

2. **문서 읽기 및 파싱**:
   - `docs/task-management/current-sprint.md` 파일 읽기
   - `docs/task-management/backlog.md` 파일 읽기
   - 현재 태스크 상태 및 진행률 파악

3. **태스크 정보 추출**:
   - 작업한 태스크의 ID, 제목, 포인트 확인
   - 관련 에픽 확인 (있는 경우)
   - 우선순위 확인

4. **문서 업데이트**:
   - `current-sprint.md`의 "완료된_태스크" 섹션에 태스크 추가
   - `current-sprint.md`의 메타데이터 업데이트 (완료_포인트, 진행률 등)
   - `backlog.md`의 태스크 상태를 "완료"로 변경
   - `backlog.md`의 메타데이터 업데이트 (완료_포인트, 진행률 등)
   - 에픽 완료율 재계산 및 업데이트 (해당되는 경우)

5. **업데이트 커밋**:
   - 태스크 관리 문서 업데이트를 별도 커밋으로 생성
   - 커밋 메시지: `docs(task-management): update task status - <태스크_ID> completed`
   - 즉시 푸시

#### 23-5. 업데이트 검증 (필수)
업데이트 후 다음을 반드시 확인:
- [ ] `current-sprint.md`에 완료된 태스크가 추가되었는지 확인
- [ ] `current-sprint.md`의 진행률이 정확히 재계산되었는지 확인
- [ ] `backlog.md`의 태스크 상태가 "완료"로 변경되었는지 확인
- [ ] `backlog.md`의 진행률이 정확히 재계산되었는지 확인
- [ ] 모든 메타데이터가 일관성 있게 업데이트되었는지 확인
- [ ] 업데이트 내용이 커밋 및 푸시되었는지 확인

#### 23-6. 예외 처리 (금지)
다음 상황에서도 업데이트를 생략할 수 없습니다:
- ❌ **작업이 작아서 생략**: 작은 작업이라도 반드시 업데이트
- ❌ **문서 업데이트가 번거로워서 생략**: 절대 생략 불가
- ❌ **나중에 업데이트하겠다고 미루기**: 즉시 업데이트 필수
- ❌ **PR 생성 후 업데이트**: PR 생성 전에 반드시 업데이트

#### 23-7. 위반 시 조치
- **작업 완료 선언 금지**: 태스크 관리 문서 업데이트 없이는 절대 작업 완료를 선언하지 않습니다
- **PR 생성 전 필수 확인**: PR 생성 전에 반드시 태스크 관리 문서 업데이트 여부를 확인합니다
- **사용자 알림**: 업데이트를 누락한 경우 사용자에게 즉시 알리고 업데이트를 수행합니다

**중요**: 이 규칙은 작업 완료의 필수 조건입니다. 태스크 관리 문서 업데이트 없이는 작업을 완료한 것으로 간주하지 않으며, PR 생성도 하지 않습니다.

이 규칙들은 프로젝트의 일관성과 품질을 유지하기 위한 필수 지침입니다.
모든 코드 변경사항은 이 규칙들을 위반하지 않아야 합니다.
