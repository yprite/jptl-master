# 개발 가이드라인

이 문서는 프로젝트의 개발 문화와 필수 규칙을 정의합니다. 모든 개발자는 이 가이드라인을 준수해야 합니다.

## 핵심 개발 원칙

### 0.1 프로젝트 계획 및 논의 필수
- **충분한 논의 선행**: 코드 작업 전에 프로젝트 아이디어, 범위, 요구사항을 사용자와 충분히 논의합니다
- **프로젝트 명세화**: 무엇을 만들지, 왜 만드는지, 어떻게 만드는지 명확히 정의합니다
- **합의 기반 진행**: 모든 주요 결정사항은 사용자와 합의된 후 진행합니다
- **요구사항 문서화**: 논의 내용을 docs/requirements.md에 기록하고 Git 커밋합니다

### 0.2 오버엔지니어링 방지
- **KISS 원칙 준수**: "Keep It Simple, Stupid" - 불필요하게 복잡한 설계를 피합니다.
- **YAGNI 원칙 준수**: "You Aren't Gonna Need It" - 실제로 필요한 기능만 구현합니다.
- **현재 요구사항에 집중**: 미래의 잠재적 요구사항을 위해 과도한 추상화를 하지 않습니다.

### 0.3 Git 관리 (커밋 + 푸시)
- **커밋 크기 제한**: 하나의 커밋은 최대 100라인으로 유지합니다.
- **단일 책임 원칙**: 하나의 커밋은 하나의 논리적 변경사항만 포함합니다.
- **빈번한 커밋**: 작업을 작은 단위로 나누어 자주 커밋합니다.
- **모든 작업 즉시 커밋**: 코드 변경, 문서 업데이트, 설정 변경 등 모든 작업을 즉시 커밋합니다
- **작업 단위별 커밋**: 논의, 계획, 구현, 테스트 등 각 단계별로 커밋합니다
- **모든 커밋 즉시 푸시**: develop 브랜치의 모든 커밋은 즉시 origin에 푸시합니다
- **원격 동기화 유지**: 로컬과 원격 저장소의 동기화를 항상 유지합니다

### 0.4 개발 프로세스 (문서 → 테스트 → 개발 → 커밋 → PR → 태스크 업데이트)
- **문서 우선**: 모든 개발 작업은 관련 문서 작성부터 시작합니다.
- **테스트 주도**: 문서 작성 후 실패하는 테스트를 먼저 작성합니다.
- **표준화된 테스트 실행**: 반드시 `./run_tests.sh` 스크립트를 사용하여 테스트를 수행합니다.
- **점진적 개발**: Red-Green-Refactor 사이클을 준수하여 최소한의 코드로 테스트를 통과시킵니다.
- **문서 동기화**: 구현 중 문서와 다른 내용이 발견되면 즉시 문서를 업데이트합니다.
- **커밋 규칙**: 모든 테스트가 통과한 후에만 커밋을 진행합니다.
- **PR 필수**: 모든 변경사항은 Pull Request를 통해 리뷰를 거칩니다.
- **태스크 업데이트**: PR 병합 후 task 관리 문서를 업데이트합니다.

#### 상세 프로세스:
1. **문서 작성**: 요구사항, 설계, API 명세 등 관련 문서를 작성합니다.
2. **테스트 작성**: 실패하는 테스트 케이스를 먼저 작성합니다 (Red).
3. **코드 구현**: 테스트를 통과시키는 최소한의 코드를 작성합니다 (Green).
4. **리팩토링**: 코드를 개선하되 테스트는 계속 통과해야 합니다 (Refactor).
5. **문서 검증**: 구현 내용과 문서의 일치성을 확인하고 업데이트합니다.
6. **테스트 실행**: `./run_tests.sh` 스크립트를 사용하여 모든 테스트가 통과하는지 확인합니다.
   - 백엔드: 커버리지 80% 이상 확인 필수
   - 프론트엔드: 커버리지 70% 이상 + 주요 플로우 100% 확인 필수
   - 커버리지 미달 시 테스트 실패로 처리
7. **커밋**: 의미 있는 커밋 메시지로 변경사항을 커밋합니다.
8. **PR 생성**: 변경사항을 설명하는 Pull Request를 생성합니다.
9. **태스크 업데이트**: 완료된 작업을 task 관리 문서에 반영합니다.

## 1. 코드 품질 및 스타일

### 1.1 코드 스타일
- **언어**: 주로 Python을 사용하며, PEP 8 스타일 가이드를 준수합니다.
- **명명 규칙**:
  - 함수/변수: snake_case (예: `calculate_total`)
  - 클래스: PascalCase (예: `UserService`)
  - 상수: UPPER_SNAKE_CASE (예: `MAX_RETRY_COUNT`)
- **줄 길이**: 한 줄에 88자 이내로 제한합니다.
- **들여쓰기**: 스페이스 4개를 사용합니다.

### 1.2 코드 구조
- 각 모듈은 단일 책임을 가져야 합니다.
- 함수는 20줄 이내로 유지합니다 (긴 함수는 분리).
- 주석은 코드의 의도를 설명하며, 불필요한 주석은 피합니다.

### 1.3 프론트엔드 특화 규칙

#### 컴포넌트 설계 원칙
- **Atomic Design**: atoms → molecules → organisms → templates → pages
- **재사용성 우선**: 범용 컴포넌트 설계
- **단방향 데이터 흐름**: props down, events up
- **컴포넌트 합성**: 상속 대신 합성 사용

#### 상태 관리 전략
- **지역 상태 우선**: useState로 충분한 경우 전역 상태 사용하지 않음
- **상태 구조화**: 관련된 상태를 하나의 객체로 그룹화
- **불변성 유지**: 상태 직접 수정 금지, immer 또는 spread 연산자 사용
- **상태 선택적 구독**: 필요한 상태만 구독

#### 성능 최적화
- **메모이제이션**: React.memo, useMemo, useCallback 적절히 사용
- **코드 스플리팅**: 페이지별/컴포넌트별 청크 분리
- **이미지 최적화**: WebP 포맷, lazy loading, responsive images
- **번들 분석**: webpack-bundle-analyzer로 번들 크기 모니터링

#### 접근성 및 UX
- **WCAG 2.1 AA 준수**: 색 대비, 키보드 네비게이션, 스크린 리더 지원
- **시맨틱 HTML**: 적절한 heading 구조, landmark roles
- **포커스 관리**: 포커스 순서, 포커스 트랩, 초기 포커스 설정
- **ARIA 속성**: 필요한 경우에만 사용, 네이티브 HTML 우선

#### 스타일링 및 UI
- **CSS 방법론**: BEM 또는 CSS Modules 사용
- **반응형 디자인**: 모바일 우선 접근법
- **다크 모드 지원**: CSS 변수와 미디어 쿼리 활용
- **일관된 디자인 토큰**: 색상, 타이포그래피, 간격 시스템화

#### 파일 및 폴더 구조
```
frontend/
├── src/
│   ├── components/        # 재사용 컴포넌트
│   │   ├── ui/           # 기본 UI 컴포넌트 (Button, Input 등)
│   │   ├── layout/       # 레이아웃 컴포넌트
│   │   └── feature/      # 기능별 컴포넌트
│   ├── hooks/            # 커스텀 훅
│   ├── utils/            # 유틸리티 함수
│   ├── constants/        # 상수 정의
│   ├── types/            # TypeScript 타입 정의
│   ├── styles/           # 글로벌 스타일 및 테마
│   ├── contexts/         # React Context
│   └── pages/            # 페이지 컴포넌트
├── public/               # 정적 파일
└── tests/                # 테스트 파일
```

#### 에러 처리 및 로깅
- **에러 바운더리**: 예상치 못한 에러를 우아하게 처리
- **사용자 친화적 에러**: 기술적 세부사항 숨기기
- **클라이언트 사이드 로깅**: 에러와 사용자 행동 추적
- **오프라인 처리**: PWA 기능을 위한 서비스 워커

#### 브라우저 호환성
- **대상 브라우저 정의**: 지원할 브라우저 명시
- **폴리필 관리**: 필요한 폴리필만 포함
- **기능 탐지**: 모던 API 사용 전 지원 여부 확인
- **점진적 향상**: 기본 기능부터 시작해 기능 확장

#### SEO 및 웹 표준
- **메타 태그 최적화**: Open Graph, Twitter Cards
- **구조화 데이터**: JSON-LD 스키마 마크업
- **페이지 로딩 성능**: Core Web Vitals 최적화
- **크롤러 친화적**: 서버 사이드 렌더링 고려

## 2. 버전 관리 (Git)

### 2.1 브랜치 전략
- `main`: 프로덕션 배포용 브랜치
- `develop`: 개발 중인 기능 통합 브랜치
- `feature/*`: 새로운 기능 개발 (예: `feature/user-authentication`)
- `bugfix/*`: 버그 수정 (예: `bugfix/login-error`)
- `hotfix/*`: 긴급 수정 (예: `hotfix/security-patch`)

### 2.2 커밋 메시지 규칙
커밋 메시지는 다음 형식을 따릅니다:
```
<type>(<scope>): <subject>

<body>

<footer>
```

- **type**: feat, fix, docs, style, refactor, test, chore 중 하나
- **scope**: 변경된 영역 (예: api, ui, db)
- **subject**: 50자 이내의 간단한 설명
- **body**: 자세한 설명 (선택사항)
- **footer**: 이슈 번호나 Breaking Changes (선택사항)

예시:
```
feat(auth): Add user login functionality

- Implement JWT token authentication
- Add login/logout endpoints

Closes #123
```

### 2.3 Push 규칙
- **브랜치 필수 생성**: 모든 작업은 새로운 브랜치를 생성하여 진행합니다
- **작업 단위별 브랜치**: 하나의 논리적 작업 단위마다 별도 브랜치를 생성합니다
- **완료 후 Push**: 해당 브랜치의 개발 작업이 완료된 후에만 push합니다
- **브랜치 네이밍**: `feature/`, `bugfix/`, `hotfix/`, `docs/`, `refactor/` 등의 접두사를 사용합니다

## 3. 테스트 전략

### 3.1 백엔드 테스트 종류
- **단위 테스트**: 각 함수/메서드의 동작 검증
- **시나리오 테스트**: API 엔드포인트 간 상호작용 및 데이터 흐름 검증
- **Acceptance 테스트**: 사용자 요구사항 충족 여부 및 전체 API 시스템 검증

### 3.2 프론트엔드 테스트 종류
- **단위 테스트**: 컴포넌트, 훅, 유틸리티 함수의 개별 동작 검증
- **시나리오 테스트**: 컴포넌트 간 상호작용 및 사용자 시나리오 검증
- **Acceptance 테스트**: 실제 브라우저 환경에서의 전체 사용자 플로우 검증

#### 프론트엔드 특화 테스트
- **시각적 회귀 테스트**: UI 변경 감지 및 시각적 일관성 검증
- **접근성 테스트**: WCAG 준수 및 사용자 접근성 검증
- **성능 테스트**: 로딩 속도, 메모리 사용량, 렌더링 성능 측정

### 3.3 테스트 커버리지
- 백엔드: 최소 80%의 코드 커버리지 유지
- 프론트엔드: 최소 70%의 코드 커버리지 + 주요 사용자 플로우 100% 커버리지
- 새로운 기능 추가 시 반드시 해당 영역의 테스트 코드를 작성합니다.

### 3.4 테스트 도구
#### 백엔드
- 단위/시나리오 테스트: pytest, unittest
- API 테스트: requests, httpx
- 데이터베이스 테스트: pytest fixtures

#### 프론트엔드
- 단위/시나리오 테스트: Jest + React Testing Library
- E2E/Acceptance 테스트: Cypress, Playwright
- 시각적 회귀 테스트: Chromatic, Percy
- 접근성 테스트: axe-core, Lighthouse

### 3.5 테스트 안티패턴 및 주의사항

#### 백엔드 테스트 안티패턴
- **데이터베이스 직접 테스트 금지**: 실제 DB 대신 인메모리 DB나 목(mock) 사용
- **외부 API 호출 금지**: 모든 외부 의존성은 목으로 대체
- **시간 의존적 테스트 금지**: 시간 관련 로직은 고정된 시간으로 테스트
- **비결정적 테스트 금지**: 랜덤 값이나 현재 시간 사용하지 않음
- **테스트 간 상태 공유 금지**: 각 테스트는 독립적으로 실행 가능

#### 프론트엔드 테스트 안티패턴
- **실제 DOM 조작 금지**: React Testing Library의 screen API 사용
- **비동기 처리 무시 금지**: 모든 비동기 작업에 await 사용
- **구현 세부사항 테스트 금지**: 사용자 관점의 동작만 테스트
- **타이머 의존적 테스트 금지**: jest.useFakeTimers()로 시간 제어
- **브라우저 API 직접 사용 금지**: jsdom이나 목으로 대체

#### 공통 안티패턴 방지
- **테스트가 너무 큼**: 하나의 테스트는 하나의 개념만 검증
- **테스트 이름이 모호함**: "should return user when valid id"처럼 명확한 이름 사용
- **하드코딩된 테스트 데이터**: 테스트 픽스처나 팩토리 사용
- **정리되지 않은 테스트**: afterEach/cleanup으로 리소스 정리
- **무의미한 어설션**: 실제로 검증할 가치가 있는 것만 테스트
- **테스트가 느림**: 단위 테스트는 100ms 이내, 통합 테스트는 1초 이내
- **깨지기 쉬운 테스트**: 구현 변경에 영향받지 않는 테스트 작성

## 4. 코드 리뷰 프로세스

### 4.1 Pull Request 규칙
- 모든 변경사항은 Pull Request를 통해 제출합니다.
- 최소 1명의 승인이 필요합니다.
- CI/CD 파이프라인이 통과해야 병합 가능합니다.

### 4.2 리뷰 포인트
- 코드의 가독성과 유지보수성
- 보안 취약점
- 성능 이슈
- 테스트 커버리지

## 5. AI 친화적 문서화

### 5.1 문서화 목적
- **AI 파싱 최적화**: AI가 빠르게 이해하고 분석할 수 있는 구조화된 데이터 형식 사용
- **실시간 상황 파악**: 코드 변경사항과 함께 자동으로 문서 업데이트
- **질문 기반 조회**: 사용자가 질문하면 AI가 문서를 기반으로 즉시 답변
- **자동화된 추적**: TDD 사이클, 커밋 분석을 통한 진행상황 자동 기록

### 5.2 문서 구조 및 포맷
```
docs/
├── task-management/      # AI 파싱용 태스크 데이터
│   ├── current-sprint.md # 현재 스프린트 상태 (키-값 포맷)
│   ├── backlog.md        # 백로그 상태 (구조화된 데이터)
│   └── README.md         # AI 워크플로우 설명
├── architecture/         # 아키텍처 설계 문서
├── api/                  # API 명세 (OpenAPI 우선)
├── development/          # 개발 환경 및 프로세스
└── CHANGELOG.md          # 변경 이력 (자동 생성)
```

### 5.3 AI 파싱용 데이터 포맷
- **키-값 쌍**: `키: 값` 형식으로 AI가 쉽게 파싱 가능
- **구조화된 목록**: `- 항목: 설명` 형식으로 계층적 정보 표현
- **메타데이터 우선**: 파일 상단에 핵심 메타데이터 배치
- **자동화 태그**: AI가 인식할 수 있는 특수 태그 사용

### 5.4 코드 문서화 규칙
- **docstring 필수**: 모든 public 함수/클래스에 Google/NumPy 스타일 docstring
- **타입 힌트**: 함수 파라미터와 리턴값에 타입 힌트 명시
- **복잡도 주석**: 사이클로매틱 복잡도가 10 이상인 함수에 설명 주석
- **AI 친화적 네이밍**: 함수/변수명이 자체 설명적(self-documenting)으로 작성

### 5.5 자동화된 문서 관리
- **커밋 훅 연동**: 코드 푸시 시 관련 문서 자동 업데이트
- **테스트 결과 연동**: TDD 완료 시 태스크 상태 자동 변경
- **메트릭스 추적**: 코드 커버리지, 복잡도, 변경 빈도 자동 기록
- **실시간 동기화**: AI가 코드 변경을 감지하여 문서 즉시 업데이트

## 6. 보안 가이드라인

### 6.1 일반 원칙
- 민감한 정보(비밀번호, API 키)는 환경 변수로 관리합니다.
- 입력값 검증을 철저히 수행합니다.
- SQL 인젝션, XSS 등의 취약점을 방지합니다.

### 6.2 인증/인가
- JWT 토큰은 안전하게 저장하고 만료 시간을 설정합니다.
- 역할 기반 접근 제어(RBAC)를 구현합니다.

## 7. 에러 처리 및 로깅

### 7.1 에러 처리
- 예외는 적절한 수준에서 처리합니다.
- 사용자에게는 친화적인 에러 메시지를 제공합니다.

### 7.2 로깅
- 로그 레벨: DEBUG, INFO, WARNING, ERROR, CRITICAL
- 민감한 정보는 로그에 포함하지 않습니다.
- 로그는 구조화하여 저장합니다.

## 8. 성능 및 최적화

### 8.1 성능 기준
- API 응답 시간: 500ms 이내
- 데이터베이스 쿼리: N+1 문제 방지
- 메모리 사용량: 합리적인 범위 유지

### 8.2 최적화
- 불필요한 데이터베이스 쿼리 제거
- 캐싱 전략 구현
- 코드 프로파일링을 통한 병목 지점 식별

## 9. 배포 및 운영

### 9.1 CI/CD
- 모든 커밋에 대해 자동 테스트 실행
- 코드 품질 검사 (linting, formatting)
- 보안 취약점 스캔

### 9.2 모니터링
- 애플리케이션 성능 모니터링
- 에러 추적 및 알림
- 사용자 행동 분석

## 11. 서버 아키텍처 (DDD 기반)

### 11.1 DDD (Domain-Driven Design) 원칙
- **도메인 중심 설계**: 비즈니스 로직을 중심으로 한 설계
- **유비쿼터스 언어**: 도메인 전문가와 개발자가 공유하는 용어 사용
- **레이어드 아키텍처**: 관심사 분리를 통한 구조화

### 11.2 아키텍처 레이어
#### 도메인 레이어 (Domain Layer)
- **엔티티 (Entity)**: 고유 식별자를 가진 도메인 객체
- **값 객체 (Value Object)**: 불변의 값 기반 객체
- **도메인 서비스 (Domain Service)**: 엔티티나 값 객체에 속하지 않는 비즈니스 로직
- **애그리게이트 (Aggregate)**: 일관성 경계를 갖는 도메인 객체 그룹

#### 애플리케이션 레이어 (Application Layer)
- **애플리케이션 서비스**: 유스케이스 조율 및 트랜잭션 관리
- **커맨드/쿼리 객체**: 입력 데이터 캡슐화
- **이벤트 발행**: 도메인 이벤트 처리

#### 인프라스트럭처 레이어 (Infrastructure Layer)
- **리포지토리 구현**: 데이터 영속성 처리
- **외부 서비스 어댑터**: API 클라이언트, 메시지 큐 등
- **프레임워크 통합**: 웹 프레임워크, ORM 등

#### 프레젠테이션 레이어 (Presentation Layer)
- **컨트롤러**: HTTP 요청 처리 및 응답 생성
- **DTO (Data Transfer Object)**: 레이어 간 데이터 전송 객체
- **API 문서화**: OpenAPI/Swagger 기반

### 11.3 DDD 패턴 적용 가이드
#### 폴더 구조 예시
```
backend/
├── domain/
│   ├── entities/          # 엔티티 클래스
│   ├── value_objects/     # 값 객체 클래스
│   ├── services/          # 도메인 서비스
│   └── aggregates/        # 애그리게이트 루트
├── application/
│   ├── services/          # 애플리케이션 서비스
│   ├── commands/          # 커맨드 객체
│   └── queries/           # 쿼리 객체
├── infrastructure/
│   ├── repositories/      # 리포지토리 구현
│   ├── adapters/          # 외부 서비스 어댑터
│   └── config/            # 설정 파일
└── presentation/
    ├── controllers/       # API 컨트롤러
    ├── dto/              # 데이터 전송 객체
    └── middleware/       # 미들웨어
```

#### 구현 원칙
- **의존성 역전**: 고수준 모듈이 저수준 모듈에 의존하지 않음
- **단일 책임**: 각 클래스는 하나의 책임만 가짐
- **개방 폐쇄**: 확장에는 열려있고, 수정에는 닫혀있음
- **인터페이스 분리**: 클라이언트가 필요하지 않은 인터페이스에 의존하지 않음

### 11.4 도메인 모델링 가이드
- **엔티티 식별**: 비즈니스적으로 의미 있는 고유 식별자 사용
- **애그리게이트 설계**: 일관성 경계와 트랜잭션 경계 고려
- **도메인 이벤트**: 상태 변경을 이벤트로 표현
- **명세 패턴**: 복잡한 쿼리 로직을 명세 객체로 분리

## 12. 개발 환경 설정

### 12.1 필수 도구
- Python 3.9+
- Docker & Docker Compose
- Git
- VS Code 또는 Cursor (권장)

### 12.2 의존성 관리
- `requirements.txt` 또는 `pyproject.toml` 사용
- 의존성은 최소한으로 유지
- 취약한 패키지는 즉시 업데이트

## 13. 태스크 및 스프린트 관리

### 13.1 스프린트 운영 원칙
- **스프린트 주기**: 1주 단위 (월요일 ~ 일요일)
- **목표**: 매주 최소 1개의 기능 완성 또는 주요 개선
- **프로세스**: 계획 → 실행 → 리뷰 → 회고

### 13.2 우선순위 체계
- **🔴 P0 (Critical)**: 시스템 다운, 보안 이슈, 긴급 버그
- **🟠 P1 (High)**: 핵심 기능, 사용자 경험 영향
- **🟡 P2 (Medium)**: 기능 개선, 기술 부채 해결
- **🟢 P3 (Low)**: 사소한 개선, 미래 대비 작업

### 13.3 태스크 관리 규칙
- **태스크 템플릿 사용**: 모든 태스크는 표준 템플릿 준수
- **수용 기준 명시**: 완료 조건을 구체적으로 정의
- **작은 단위 유지**: 하나의 태스크는 1-2일 내 완료 가능
- **상태 추적**: 진행 상황을 실시간으로 업데이트

### 13.4 AI 기반 문서화 요구사항
- **실시간 태스크 추적**: AI가 코드 변경사항 분석하여 자동 상태 업데이트
- **질문 기반 조회**: 사용자가 "진행상황은?" 물으면 AI가 즉시 답변
- **자동화된 메트릭스**: 테스트 결과, 커버리지, 복잡도 자동 기록
- **메타데이터 중심**: 모든 문서에 AI 파싱용 메타데이터 포함

### 13.5 의사소통 규칙
- **일일 스탠드업**: 매일 15분 내 진행 상황 공유
- **블로킹 이슈**: 즉시 보고 및 해결 방안 논의
- **주간 리뷰**: 금요일 성과 평가 및 피드백
- **투명성**: 모든 작업 진행 상황 공개

## 14. AI 어시스턴트 행동 지침

### 14.1 AI 우선 개발 방식
- **AI-사용자 협업 중심**: AI가 코드 작성, 테스트, 문서화의 주체가 됨
- **질문 기반 진행**: 사용자가 "무엇을 할까?"라고 물으면 AI가 제안하고 실행
- **자동화된 추적**: 코드 변경사항을 실시간으로 태스크 상태에 반영

### 14.2 AI 친화적 문서화
- **실시간 문서 업데이트**: 코드 변경 즉시 관련 문서 자동 업데이트
- **AI 파싱 최적화**: 키-값 포맷, 구조화된 데이터로 문서 작성
- **메타데이터 중심**: 모든 문서에 AI가 쉽게 파악할 수 있는 핵심 정보 배치

### 14.3 태스크 관리 자동화
- **TDD 기반 진행**: 테스트 먼저 작성, 구현, 문서화 자동 진행
- **상태 자동 추적**: 커밋 분석으로 진행상황 실시간 반영
- **우선순위 자동 제안**: 백로그 분석으로 다음 작업 추천

### 14.4 커뮤니케이션 방식
- **명확한 상태 보고**: "현재 ~ 작업 중", "다음 추천 작업은 ~" 형식
- **구체적인 제안**: "이 작업을 이렇게 구현하겠습니다"로 진행
- **즉시 피드백**: 사용자 질문에 즉시 답변하고 다음 단계 제안

### 14.5 품질 보증
- **자동화된 테스트**: 모든 변경사항에 대한 테스트 자동 실행
- **코드 품질 검사**: PEP 8 준수, 타입 힌트, docstring 검증
- **보안 및 성능 검토**: 취약점 스캔, 성능 메트릭스 자동 측정

이 가이드라인은 프로젝트의 성장에 따라 업데이트될 수 있습니다. 변경사항은 AI-사용자 토의를 통해 결정합니다.
